{"ast":null,"code":"import _slicedToArray from \"D:\\\\Graduation Essay\\\\KidsDrawing\\\\client\\\\KidsDrawing\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"D:\\\\Graduation Essay\\\\KidsDrawing\\\\client\\\\KidsDrawing\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject6() {\n  const data = _taggedTemplateLiteral([\"\\n  display: flex;\\n  flex-direction: column;\\n\"]);\n\n  _templateObject6 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  const data = _taggedTemplateLiteral([\"\\n  * {\\n    box-sizing: border-box;\\n  }\\n\"]);\n\n  _templateObject5 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  const data = _taggedTemplateLiteral([\"\\n  position: relative;\\n\"]);\n\n  _templateObject4 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  const data = _taggedTemplateLiteral([\"\\n  height: \", \";\\n  width: \", \";\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n\"]);\n\n  _templateObject3 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n  font-size: \", \";\\n  padding: \", \";\\n  height: \", \";\\n  border: 1px solid \", \";\\n  border-radius: 5px;\\n  color: \", \";\\n  background-color: \", \";\\n  width: 100%;\\n\\n  &:focus {\\n    outline: none;\\n  }\\n\"]);\n\n  _templateObject2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n  margin: 10px 0 0;\\n  background-color: #fff;\\n  box-shadow: rgba(0, 0, 0, 0.1) 0 0 0 0, rgba(0, 0, 0, 0.1) 0px 4px 11px;\\n  border-radius: 5px;\\n  > ul {\\n    list-style-type: none;\\n    margin: 0;\\n    padding: 0;\\n    > li {\\n      padding: 10px 20px;\\n      background-color: #fff;\\n      border: 1px solid\\n        \", \";\\n      height: 40px;\\n      display: flex;\\n      align-items: center;\\n      &:hover {\\n        background-color: \", \";\\n        cursor: pointer;\\n      }\\n      &:first-child {\\n        border-top-left-radius: 5px;\\n        border-top-right-radius: 5px;\\n      }\\n      &:last-child {\\n        border-bottom-left-radius: 5px;\\n        border-bottom-right-radius: 5px;\\n      }\\n      &:not(:first-child) {\\n        border-top: 0;\\n      }\\n    }\\n  }\\n\"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b2) => {\n  for (var prop in b2 || (b2 = {})) if (__hasOwnProp.call(b2, prop)) __defNormalProp(a, prop, b2[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b2)) {\n    if (__propIsEnum.call(b2, prop)) __defNormalProp(a, prop, b2[prop]);\n  }\n  return a;\n};\n\nimport r$1, { useContext, useRef, useLayoutEffect, createElement, useEffect, useState } from \"react\";\n\nfunction isArray(value) {\n  return !Array.isArray ? getTag(value) === \"[object Array]\" : Array.isArray(value);\n}\n\nconst INFINITY = 1 / 0;\n\nfunction baseToString(value) {\n  if (typeof value == \"string\") {\n    return value;\n  }\n\n  let result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\n\nfunction toString(value) {\n  return value == null ? \"\" : baseToString(value);\n}\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\n\nfunction isBoolean(value) {\n  return value === true || value === false || isObjectLike(value) && getTag(value) == \"[object Boolean]\";\n}\n\nfunction isObject(value) {\n  return typeof value === \"object\";\n}\n\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null;\n}\n\nfunction isDefined(value) {\n  return value !== void 0 && value !== null;\n}\n\nfunction isBlank(value) {\n  return !value.trim().length;\n}\n\nfunction getTag(value) {\n  return value == null ? value === void 0 ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(value);\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = \"Extended search is not available\";\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = key => \"Invalid value for key \".concat(key);\n\nconst PATTERN_LENGTH_TOO_LARGE = max => \"Pattern length exceeds max of \".concat(max, \".\");\n\nconst MISSING_KEY_PROPERTY = name => \"Missing \".concat(name, \" property in key\");\n\nconst INVALID_KEY_WEIGHT_VALUE = key => \"Property 'weight' in key '\".concat(key, \"' must be a positive integer\");\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n    let totalWeight = 0;\n    keys.forEach(key => {\n      let obj = createKey(key);\n      totalWeight += obj.weight;\n\n      this._keys.push(obj);\n\n      this._keyMap[obj.id] = obj;\n      totalWeight += obj.weight;\n    });\n\n    this._keys.forEach(key => {\n      key.weight /= totalWeight;\n    });\n  }\n\n  get(keyId) {\n    return this._keyMap[keyId];\n  }\n\n  keys() {\n    return this._keys;\n  }\n\n  toJSON() {\n    return JSON.stringify(this._keys);\n  }\n\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, \"name\")) {\n      throw new Error(MISSING_KEY_PROPERTY(\"name\"));\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, \"weight\")) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n  }\n\n  return {\n    path,\n    id,\n    weight,\n    src\n  };\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split(\".\");\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join(\".\") : key;\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj2, path2, index2) => {\n    if (!isDefined(obj2)) {\n      return;\n    }\n\n    if (!path2[index2]) {\n      list.push(obj2);\n    } else {\n      let key = path2[index2];\n      const value = obj2[key];\n\n      if (!isDefined(value)) {\n        return;\n      }\n\n      if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path2, index2 + 1);\n        }\n      } else if (path2.length) {\n        deepGet(value, path2, index2 + 1);\n      }\n    }\n  };\n\n  deepGet(obj, isString(path) ? path.split(\".\") : path, 0);\n  return arr ? list : list[0];\n}\n\nconst MatchOptions = {\n  includeMatches: false,\n  findAllMatches: false,\n  minMatchCharLength: 1\n};\nconst BasicOptions = {\n  isCaseSensitive: false,\n  includeScore: false,\n  keys: [],\n  shouldSort: true,\n  sortFn: (a, b2) => a.score === b2.score ? a.idx < b2.idx ? -1 : 1 : a.score < b2.score ? -1 : 1\n};\nconst FuzzyOptions = {\n  location: 0,\n  threshold: 0.6,\n  distance: 100\n};\nconst AdvancedOptions = {\n  useExtendedSearch: false,\n  getFn: get,\n  ignoreLocation: false,\n  ignoreFieldNorm: false\n};\n\nvar Config = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);\n\nconst SPACE = /[^ ]+/g;\n\nfunction norm(mantissa = 3) {\n  const cache = new Map();\n  const m2 = Math.pow(10, mantissa);\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens);\n      }\n\n      const norm2 = 1 / Math.sqrt(numTokens);\n      const n2 = parseFloat(Math.round(norm2 * m2) / m2);\n      cache.set(numTokens, n2);\n      return n2;\n    },\n\n    clear() {\n      cache.clear();\n    }\n\n  };\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn\n  } = {}) {\n    this.norm = norm(3);\n    this.getFn = getFn;\n    this.isCreated = false;\n    this.setIndexRecords();\n  }\n\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return;\n    }\n\n    this.isCreated = true;\n\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]];\n  }\n\n  size() {\n    return this.records.length;\n  }\n\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return;\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n    this.records.push(record);\n  }\n\n  _addObject(doc, docIndex) {\n    let record = {\n      i: docIndex,\n      $: {}\n    };\n    this.keys.forEach((key, keyIndex) => {\n      let value = this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return;\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{\n          nestedArrIndex: -1,\n          value\n        }];\n\n        while (stack.length) {\n          const _stack$pop = stack.pop(),\n                nestedArrIndex = _stack$pop.nestedArrIndex,\n                value2 = _stack$pop.value;\n\n          if (!isDefined(value2)) {\n            continue;\n          }\n\n          if (isString(value2) && !isBlank(value2)) {\n            let subRecord = {\n              v: value2,\n              i: nestedArrIndex,\n              n: this.norm.get(value2)\n            };\n            subRecords.push(subRecord);\n          } else if (isArray(value2)) {\n            value2.forEach((item, k2) => {\n              stack.push({\n                nestedArrIndex: k2,\n                value: item\n              });\n            });\n          }\n        }\n\n        record.$[keyIndex] = subRecords;\n      } else if (!isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n        record.$[keyIndex] = subRecord;\n      }\n    });\n    this.records.push(record);\n  }\n\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    };\n  }\n\n}\n\nfunction createIndex(keys, docs, {\n  getFn = Config.getFn\n} = {}) {\n  const myIndex = new FuseIndex({\n    getFn\n  });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex;\n}\n\nfunction parseIndex(data, {\n  getFn = Config.getFn\n} = {}) {\n  const keys = data.keys,\n        records = data.records;\n  const myIndex = new FuseIndex({\n    getFn\n  });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex;\n}\n\nfunction computeScore(pattern, {\n  errors = 0,\n  currentLocation = 0,\n  expectedLocation = 0,\n  distance = Config.distance,\n  ignoreLocation = Config.ignoreLocation\n} = {}) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy;\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    return proximity ? 1 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n}\n\nfunction convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n\n      start = -1;\n    }\n  }\n\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices;\n}\n\nconst MAX_BITS = 32;\n\nfunction search(text, pattern, patternAlphabet, {\n  location = Config.location,\n  distance = Config.distance,\n  threshold = Config.threshold,\n  findAllMatches = Config.findAllMatches,\n  minMatchCharLength = Config.minMatchCharLength,\n  includeMatches = Config.includeMatches,\n  ignoreLocation = Config.ignoreLocation\n} = {}) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n  }\n\n  const patternLen = pattern.length;\n  const textLen = text.length;\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  let currentThreshold = threshold;\n  let bestLocation = expectedLocation;\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  const matchMask = computeMatches ? Array(textLen) : [];\n  let index2;\n\n  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore(pattern, {\n      currentLocation: index2,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index2 + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n\n      while (i < patternLen) {\n        matchMask[index2 + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  bestLocation = -1;\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n  const mask = 1 << patternLen - 1;\n\n  for (let i = 0; i < patternLen; i += 1) {\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score2 = computeScore(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score2 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    binMax = binMid;\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n    let bitArr = Array(finish + 2);\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j2 = finish; j2 >= start; j2 -= 1) {\n      let currentLocation = j2 - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;\n\n      if (i) {\n        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];\n      }\n\n      if (bitArr[j2] & mask) {\n        finalScore = computeScore(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        if (finalScore <= currentThreshold) {\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    const score = computeScore(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    score: Math.max(1e-3, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result;\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n  }\n\n  return mask;\n}\n\nclass BitapSearch {\n  constructor(pattern, {\n    location = Config.location,\n    threshold = Config.threshold,\n    distance = Config.distance,\n    includeMatches = Config.includeMatches,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    isCaseSensitive = Config.isCaseSensitive,\n    ignoreLocation = Config.ignoreLocation\n  } = {}) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return;\n    }\n\n    const addChunk = (pattern2, startIndex) => {\n      this.chunks.push({\n        pattern: pattern2,\n        alphabet: createPatternAlphabet(pattern2),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const _this$options = this.options,\n          isCaseSensitive = _this$options.isCaseSensitive,\n          includeMatches = _this$options.includeMatches;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    if (this.pattern === text) {\n      let result2 = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result2.indices = [[0, text.length - 1]];\n      }\n\n      return result2;\n    }\n\n    const _this$options2 = this.options,\n          location = _this$options2.location,\n          distance = _this$options2.distance,\n          threshold = _this$options2.threshold,\n          findAllMatches = _this$options2.findAllMatches,\n          minMatchCharLength = _this$options2.minMatchCharLength,\n          ignoreLocation = _this$options2.ignoreLocation;\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n    this.chunks.forEach(({\n      pattern,\n      alphabet,\n      startIndex\n    }) => {\n      const _search = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      }),\n            isMatch = _search.isMatch,\n            score = _search.score,\n            indices = _search.indices;\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result;\n  }\n\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex);\n  }\n\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex);\n  }\n\n  search() {}\n\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null;\n}\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"exact\";\n  }\n\n  static get multiRegex() {\n    return /^=\"(.*)\"$/;\n  }\n\n  static get singleRegex() {\n    return /^=(.*)$/;\n  }\n\n  search(text) {\n    const isMatch = text === this.pattern;\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    };\n  }\n\n}\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"inverse-exact\";\n  }\n\n  static get multiRegex() {\n    return /^!\"(.*)\"$/;\n  }\n\n  static get singleRegex() {\n    return /^!(.*)$/;\n  }\n\n  search(text) {\n    const index2 = text.indexOf(this.pattern);\n    const isMatch = index2 === -1;\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    };\n  }\n\n}\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"prefix-exact\";\n  }\n\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/;\n  }\n\n  static get singleRegex() {\n    return /^\\^(.*)$/;\n  }\n\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    };\n  }\n\n}\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"inverse-prefix-exact\";\n  }\n\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/;\n  }\n\n  static get singleRegex() {\n    return /^!\\^(.*)$/;\n  }\n\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    };\n  }\n\n}\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"suffix-exact\";\n  }\n\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/;\n  }\n\n  static get singleRegex() {\n    return /^(.*)\\$$/;\n  }\n\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    };\n  }\n\n}\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"inverse-suffix-exact\";\n  }\n\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/;\n  }\n\n  static get singleRegex() {\n    return /^!(.*)\\$$/;\n  }\n\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    };\n  }\n\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(pattern, {\n    location = Config.location,\n    threshold = Config.threshold,\n    distance = Config.distance,\n    includeMatches = Config.includeMatches,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    isCaseSensitive = Config.isCaseSensitive,\n    ignoreLocation = Config.ignoreLocation\n  } = {}) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n\n  static get type() {\n    return \"fuzzy\";\n  }\n\n  static get multiRegex() {\n    return /^\"(.*)\"$/;\n  }\n\n  static get singleRegex() {\n    return /^(.*)$/;\n  }\n\n  search(text) {\n    return this._bitapSearch.searchIn(text);\n  }\n\n}\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n\n  static get type() {\n    return \"include\";\n  }\n\n  static get multiRegex() {\n    return /^'\"(.*)\"$/;\n  }\n\n  static get singleRegex() {\n    return /^'(.*)$/;\n  }\n\n  search(text) {\n    let location = 0;\n    let index2;\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    while ((index2 = text.indexOf(this.pattern, location)) > -1) {\n      location = index2 + patternLen;\n      indices.push([index2, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    };\n  }\n\n}\n\nconst searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];\nconst searchersLen = searchers.length;\nconst SPACE_RE = / +(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = \"|\";\n\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map(item => {\n    let query = item.trim().split(SPACE_RE).filter(item2 => item2 && !!item2.trim());\n    let results = [];\n\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n      let found = false;\n      let idx = -1;\n\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue;\n      }\n\n      idx = -1;\n\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n\n        if (token) {\n          results.push(new searcher(token, options));\n          break;\n        }\n      }\n    }\n\n    return results;\n  });\n}\n\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\nclass ExtendedSearch {\n  constructor(pattern, {\n    isCaseSensitive = Config.isCaseSensitive,\n    includeMatches = Config.includeMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    ignoreLocation = Config.ignoreLocation,\n    findAllMatches = Config.findAllMatches,\n    location = Config.location,\n    threshold = Config.threshold,\n    distance = Config.distance\n  } = {}) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_2, options) {\n    return options.useExtendedSearch;\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      };\n    }\n\n    const _this$options3 = this.options,\n          includeMatches = _this$options3.includeMatches,\n          isCaseSensitive = _this$options3.isCaseSensitive;\n    text = isCaseSensitive ? text : text.toLowerCase();\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers2 = query[i];\n      allIndices.length = 0;\n      numMatches = 0;\n\n      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {\n        const searcher = searchers2[j2];\n\n        const _searcher$search = searcher.search(text),\n              isMatch = _searcher$search.isMatch,\n              indices = _searcher$search.indices,\n              score = _searcher$search.score;\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break;\n        }\n      }\n\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result;\n      }\n    }\n\n    return {\n      isMatch: false,\n      score: 1\n    };\n  }\n\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options);\n    }\n  }\n\n  return new BitapSearch(pattern, options);\n}\n\nconst LogicalOperator = {\n  AND: \"$and\",\n  OR: \"$or\"\n};\nconst KeyType = {\n  PATH: \"$path\",\n  PATTERN: \"$val\"\n};\n\nconst isExpression = query => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = query => !!query[KeyType.PATH];\n\nconst isLeaf = query => !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = query => ({\n  [LogicalOperator.AND]: Object.keys(query).map(key => ({\n    [key]: query[key]\n  }))\n});\n\nfunction parse(query, options, {\n  auto = true\n} = {}) {\n  const next = query2 => {\n    let keys = Object.keys(query2);\n    const isQueryPath = isPath(query2);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {\n      return next(convertToExplicit(query2));\n    }\n\n    if (isLeaf(query2)) {\n      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];\n      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj;\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n    keys.forEach(key => {\n      const value = query2[key];\n\n      if (isArray(value)) {\n        value.forEach(item => {\n          node.children.push(next(item));\n        });\n      }\n    });\n    return node;\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query);\n}\n\nfunction computeScore$1(results, {\n  ignoreFieldNorm = Config.ignoreFieldNorm\n}) {\n  results.forEach(result => {\n    let totalScore = 1;\n    result.matches.forEach(({\n      key,\n      norm: norm2,\n      score\n    }) => {\n      const weight = key ? key.weight : null;\n      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));\n    });\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return;\n  }\n\n  matches.forEach(match => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return;\n    }\n\n    const indices = match.indices,\n          value = match.value;\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(results, docs, {\n  includeMatches = Config.includeMatches,\n  includeScore = Config.includeScore\n} = {}) {\n  const transformers = [];\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n  return results.map(result => {\n    const idx = result.idx;\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach(transformer => {\n        transformer(result, data);\n      });\n    }\n\n    return data;\n  });\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index2) {\n    this.options = __spreadValues(__spreadValues({}, Config), options);\n\n    if (this.options.useExtendedSearch && false) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n    this.setCollection(docs, index2);\n  }\n\n  setCollection(docs, index2) {\n    this._docs = docs;\n\n    if (index2 && !(index2 instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE);\n    }\n\n    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {\n      getFn: this.options.getFn\n    });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return;\n    }\n\n    this._docs.push(doc);\n\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = () => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n        results.push(doc);\n      }\n    }\n\n    return results;\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex;\n  }\n\n  search(query, {\n    limit = -1\n  } = {}) {\n    const _this$options4 = this.options,\n          includeMatches = _this$options4.includeMatches,\n          includeScore = _this$options4.includeScore,\n          shouldSort = _this$options4.shouldSort,\n          sortFn = _this$options4.sortFn,\n          ignoreFieldNorm = _this$options4.ignoreFieldNorm;\n    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n    computeScore$1(results, {\n      ignoreFieldNorm\n    });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    });\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const records = this._myIndex.records;\n    const results = [];\n    records.forEach(({\n      v: text,\n      i: idx,\n      n: norm2\n    }) => {\n      if (!isDefined(text)) {\n        return;\n      }\n\n      const _searcher$searchIn = searcher.searchIn(text),\n            isMatch = _searcher$searchIn.isMatch,\n            score = _searcher$searchIn.score,\n            indices = _searcher$searchIn.indices;\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{\n            score,\n            value: text,\n            norm: norm2,\n            indices\n          }]\n        });\n      }\n    });\n    return results;\n  }\n\n  _searchLogical(query) {\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const keyId = node.keyId,\n              searcher = node.searcher;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [{\n            idx,\n            item,\n            matches\n          }];\n        }\n\n        return [];\n      }\n\n      switch (node.operator) {\n        case LogicalOperator.AND:\n          {\n            const res = [];\n\n            for (let i = 0, len = node.children.length; i < len; i += 1) {\n              const child = node.children[i];\n              const result = evaluate(child, item, idx);\n\n              if (result.length) {\n                res.push(...result);\n              } else {\n                return [];\n              }\n            }\n\n            return res;\n          }\n\n        case LogicalOperator.OR:\n          {\n            const res = [];\n\n            for (let i = 0, len = node.children.length; i < len; i += 1) {\n              const child = node.children[i];\n              const result = evaluate(child, item, idx);\n\n              if (result.length) {\n                res.push(...result);\n                break;\n              }\n            }\n\n            return res;\n          }\n      }\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n    records.forEach(({\n      $: item,\n      i: idx\n    }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          if (!resultMap[idx]) {\n            resultMap[idx] = {\n              idx,\n              item,\n              matches: []\n            };\n            results.push(resultMap[idx]);\n          }\n\n          expResults.forEach(({\n            matches\n          }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n    return results;\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const _this$_myIndex = this._myIndex,\n          keys = _this$_myIndex.keys,\n          records = _this$_myIndex.records;\n    const results = [];\n    records.forEach(({\n      $: item,\n      i: idx\n    }) => {\n      if (!isDefined(item)) {\n        return;\n      }\n\n      let matches = [];\n      keys.forEach((key, keyIndex) => {\n        matches.push(...this._findMatches({\n          key,\n          value: item[keyIndex],\n          searcher\n        }));\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n    return results;\n  }\n\n  _findMatches({\n    key,\n    value,\n    searcher\n  }) {\n    if (!isDefined(value)) {\n      return [];\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({\n        v: text,\n        i: idx,\n        n: norm2\n      }) => {\n        if (!isDefined(text)) {\n          return;\n        }\n\n        const _searcher$searchIn2 = searcher.searchIn(text),\n              isMatch = _searcher$searchIn2.isMatch,\n              score = _searcher$searchIn2.score,\n              indices = _searcher$searchIn2.indices;\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm: norm2,\n            indices\n          });\n        }\n      });\n    } else {\n      const text = value.v,\n            norm2 = value.n;\n\n      const _searcher$searchIn3 = searcher.searchIn(text),\n            isMatch = _searcher$searchIn3.isMatch,\n            score = _searcher$searchIn3.score,\n            indices = _searcher$searchIn3.indices;\n\n      if (isMatch) {\n        matches.push({\n          score,\n          key,\n          value: text,\n          norm: norm2,\n          indices\n        });\n      }\n    }\n\n    return matches;\n  }\n\n}\n\nFuse.version = \"6.4.6\";\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n{\n  Fuse.parseQuery = parse;\n}\n{\n  register(ExtendedSearch);\n}\nvar reactIs$1 = {\n  exports: {}\n};\nvar reactIs_production_min = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b$1 = typeof Symbol === \"function\" && Symbol.for,\n    c = b$1 ? Symbol.for(\"react.element\") : 60103,\n    d = b$1 ? Symbol.for(\"react.portal\") : 60106,\n    e = b$1 ? Symbol.for(\"react.fragment\") : 60107,\n    f$1 = b$1 ? Symbol.for(\"react.strict_mode\") : 60108,\n    g$2 = b$1 ? Symbol.for(\"react.profiler\") : 60114,\n    h$1 = b$1 ? Symbol.for(\"react.provider\") : 60109,\n    k$1 = b$1 ? Symbol.for(\"react.context\") : 60110,\n    l = b$1 ? Symbol.for(\"react.async_mode\") : 60111,\n    m$1 = b$1 ? Symbol.for(\"react.concurrent_mode\") : 60111,\n    n$1 = b$1 ? Symbol.for(\"react.forward_ref\") : 60112,\n    p$1 = b$1 ? Symbol.for(\"react.suspense\") : 60113,\n    q$2 = b$1 ? Symbol.for(\"react.suspense_list\") : 60120,\n    r = b$1 ? Symbol.for(\"react.memo\") : 60115,\n    t = b$1 ? Symbol.for(\"react.lazy\") : 60116,\n    v$1 = b$1 ? Symbol.for(\"react.block\") : 60121,\n    w$1 = b$1 ? Symbol.for(\"react.fundamental\") : 60117,\n    x$1 = b$1 ? Symbol.for(\"react.responder\") : 60118,\n    y = b$1 ? Symbol.for(\"react.scope\") : 60119;\n\nfunction z$1(a) {\n  if (typeof a === \"object\" && a !== null) {\n    var u = a.$$typeof;\n\n    switch (u) {\n      case c:\n        switch (a = a.type, a) {\n          case l:\n          case m$1:\n          case e:\n          case g$2:\n          case f$1:\n          case p$1:\n            return a;\n\n          default:\n            switch (a = a && a.$$typeof, a) {\n              case k$1:\n              case n$1:\n              case t:\n              case r:\n              case h$1:\n                return a;\n\n              default:\n                return u;\n            }\n\n        }\n\n      case d:\n        return u;\n    }\n  }\n}\n\nfunction A$1(a) {\n  return z$1(a) === m$1;\n}\n\nreactIs_production_min.AsyncMode = l;\nreactIs_production_min.ConcurrentMode = m$1;\nreactIs_production_min.ContextConsumer = k$1;\nreactIs_production_min.ContextProvider = h$1;\nreactIs_production_min.Element = c;\nreactIs_production_min.ForwardRef = n$1;\nreactIs_production_min.Fragment = e;\nreactIs_production_min.Lazy = t;\nreactIs_production_min.Memo = r;\nreactIs_production_min.Portal = d;\nreactIs_production_min.Profiler = g$2;\nreactIs_production_min.StrictMode = f$1;\nreactIs_production_min.Suspense = p$1;\n\nreactIs_production_min.isAsyncMode = function (a) {\n  return A$1(a) || z$1(a) === l;\n};\n\nreactIs_production_min.isConcurrentMode = A$1;\n\nreactIs_production_min.isContextConsumer = function (a) {\n  return z$1(a) === k$1;\n};\n\nreactIs_production_min.isContextProvider = function (a) {\n  return z$1(a) === h$1;\n};\n\nreactIs_production_min.isElement = function (a) {\n  return typeof a === \"object\" && a !== null && a.$$typeof === c;\n};\n\nreactIs_production_min.isForwardRef = function (a) {\n  return z$1(a) === n$1;\n};\n\nreactIs_production_min.isFragment = function (a) {\n  return z$1(a) === e;\n};\n\nreactIs_production_min.isLazy = function (a) {\n  return z$1(a) === t;\n};\n\nreactIs_production_min.isMemo = function (a) {\n  return z$1(a) === r;\n};\n\nreactIs_production_min.isPortal = function (a) {\n  return z$1(a) === d;\n};\n\nreactIs_production_min.isProfiler = function (a) {\n  return z$1(a) === g$2;\n};\n\nreactIs_production_min.isStrictMode = function (a) {\n  return z$1(a) === f$1;\n};\n\nreactIs_production_min.isSuspense = function (a) {\n  return z$1(a) === p$1;\n};\n\nreactIs_production_min.isValidElementType = function (a) {\n  return typeof a === \"string\" || typeof a === \"function\" || a === e || a === m$1 || a === g$2 || a === f$1 || a === p$1 || a === q$2 || typeof a === \"object\" && a !== null && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w$1 || a.$$typeof === x$1 || a.$$typeof === y || a.$$typeof === v$1);\n};\n\nreactIs_production_min.typeOf = z$1;\n{\n  reactIs$1.exports = reactIs_production_min;\n}\n\nfunction stylis_min(W2) {\n  function M2(d2, c2, e2, h, a) {\n    for (var m2 = 0, b2 = 0, v2 = 0, n2 = 0, q2, g2, x2 = 0, K2 = 0, k2, u = k2 = q2 = 0, l2 = 0, r2 = 0, I2 = 0, t2 = 0, B3 = e2.length, J2 = B3 - 1, y2, f2 = \"\", p2 = \"\", F3 = \"\", G3 = \"\", C; l2 < B3;) {\n      g2 = e2.charCodeAt(l2);\n      l2 === J2 && b2 + n2 + v2 + m2 !== 0 && (b2 !== 0 && (g2 = b2 === 47 ? 10 : 47), n2 = v2 = m2 = 0, B3++, J2++);\n\n      if (b2 + n2 + v2 + m2 === 0) {\n        if (l2 === J2 && (0 < r2 && (f2 = f2.replace(N2, \"\")), 0 < f2.trim().length)) {\n          switch (g2) {\n            case 32:\n            case 9:\n            case 59:\n            case 13:\n            case 10:\n              break;\n\n            default:\n              f2 += e2.charAt(l2);\n          }\n\n          g2 = 59;\n        }\n\n        switch (g2) {\n          case 123:\n            f2 = f2.trim();\n            q2 = f2.charCodeAt(0);\n            k2 = 1;\n\n            for (t2 = ++l2; l2 < B3;) {\n              switch (g2 = e2.charCodeAt(l2)) {\n                case 123:\n                  k2++;\n                  break;\n\n                case 125:\n                  k2--;\n                  break;\n\n                case 47:\n                  switch (g2 = e2.charCodeAt(l2 + 1)) {\n                    case 42:\n                    case 47:\n                      a: {\n                        for (u = l2 + 1; u < J2; ++u) {\n                          switch (e2.charCodeAt(u)) {\n                            case 47:\n                              if (g2 === 42 && e2.charCodeAt(u - 1) === 42 && l2 + 2 !== u) {\n                                l2 = u + 1;\n                                break a;\n                              }\n\n                              break;\n\n                            case 10:\n                              if (g2 === 47) {\n                                l2 = u + 1;\n                                break a;\n                              }\n\n                          }\n                        }\n\n                        l2 = u;\n                      }\n\n                  }\n\n                  break;\n\n                case 91:\n                  g2++;\n\n                case 40:\n                  g2++;\n\n                case 34:\n                case 39:\n                  for (; l2++ < J2 && e2.charCodeAt(l2) !== g2;) {}\n\n              }\n\n              if (k2 === 0) break;\n              l2++;\n            }\n\n            k2 = e2.substring(t2, l2);\n            q2 === 0 && (q2 = (f2 = f2.replace(ca, \"\").trim()).charCodeAt(0));\n\n            switch (q2) {\n              case 64:\n                0 < r2 && (f2 = f2.replace(N2, \"\"));\n                g2 = f2.charCodeAt(1);\n\n                switch (g2) {\n                  case 100:\n                  case 109:\n                  case 115:\n                  case 45:\n                    r2 = c2;\n                    break;\n\n                  default:\n                    r2 = O2;\n                }\n\n                k2 = M2(c2, r2, k2, g2, a + 1);\n                t2 = k2.length;\n                0 < A2 && (r2 = X2(O2, f2, I2), C = H2(3, k2, r2, c2, D, z2, t2, g2, a, h), f2 = r2.join(\"\"), C !== void 0 && (t2 = (k2 = C.trim()).length) === 0 && (g2 = 0, k2 = \"\"));\n                if (0 < t2) switch (g2) {\n                  case 115:\n                    f2 = f2.replace(da, ea);\n\n                  case 100:\n                  case 109:\n                  case 45:\n                    k2 = f2 + \"{\" + k2 + \"}\";\n                    break;\n\n                  case 107:\n                    f2 = f2.replace(fa, \"$1 $2\");\n                    k2 = f2 + \"{\" + k2 + \"}\";\n                    k2 = w2 === 1 || w2 === 2 && L2(\"@\" + k2, 3) ? \"@-webkit-\" + k2 + \"@\" + k2 : \"@\" + k2;\n                    break;\n\n                  default:\n                    k2 = f2 + k2, h === 112 && (k2 = (p2 += k2, \"\"));\n                } else k2 = \"\";\n                break;\n\n              default:\n                k2 = M2(c2, X2(c2, f2, I2), k2, h, a + 1);\n            }\n\n            F3 += k2;\n            k2 = I2 = r2 = u = q2 = 0;\n            f2 = \"\";\n            g2 = e2.charCodeAt(++l2);\n            break;\n\n          case 125:\n          case 59:\n            f2 = (0 < r2 ? f2.replace(N2, \"\") : f2).trim();\n            if (1 < (t2 = f2.length)) switch (u === 0 && (q2 = f2.charCodeAt(0), q2 === 45 || 96 < q2 && 123 > q2) && (t2 = (f2 = f2.replace(\" \", \":\")).length), 0 < A2 && (C = H2(1, f2, c2, d2, D, z2, p2.length, h, a, h)) !== void 0 && (t2 = (f2 = C.trim()).length) === 0 && (f2 = \"\\0\\0\"), q2 = f2.charCodeAt(0), g2 = f2.charCodeAt(1), q2) {\n              case 0:\n                break;\n\n              case 64:\n                if (g2 === 105 || g2 === 99) {\n                  G3 += f2 + e2.charAt(l2);\n                  break;\n                }\n\n              default:\n                f2.charCodeAt(t2 - 1) !== 58 && (p2 += P2(f2, q2, g2, f2.charCodeAt(2)));\n            }\n            I2 = r2 = u = q2 = 0;\n            f2 = \"\";\n            g2 = e2.charCodeAt(++l2);\n        }\n      }\n\n      switch (g2) {\n        case 13:\n        case 10:\n          b2 === 47 ? b2 = 0 : 1 + q2 === 0 && h !== 107 && 0 < f2.length && (r2 = 1, f2 += \"\\0\");\n          0 < A2 * Y2 && H2(0, f2, c2, d2, D, z2, p2.length, h, a, h);\n          z2 = 1;\n          D++;\n          break;\n\n        case 59:\n        case 125:\n          if (b2 + n2 + v2 + m2 === 0) {\n            z2++;\n            break;\n          }\n\n        default:\n          z2++;\n          y2 = e2.charAt(l2);\n\n          switch (g2) {\n            case 9:\n            case 32:\n              if (n2 + m2 + b2 === 0) switch (x2) {\n                case 44:\n                case 58:\n                case 9:\n                case 32:\n                  y2 = \"\";\n                  break;\n\n                default:\n                  g2 !== 32 && (y2 = \" \");\n              }\n              break;\n\n            case 0:\n              y2 = \"\\\\0\";\n              break;\n\n            case 12:\n              y2 = \"\\\\f\";\n              break;\n\n            case 11:\n              y2 = \"\\\\v\";\n              break;\n\n            case 38:\n              n2 + b2 + m2 === 0 && (r2 = I2 = 1, y2 = \"\\f\" + y2);\n              break;\n\n            case 108:\n              if (n2 + b2 + m2 + E2 === 0 && 0 < u) switch (l2 - u) {\n                case 2:\n                  x2 === 112 && e2.charCodeAt(l2 - 3) === 58 && (E2 = x2);\n\n                case 8:\n                  K2 === 111 && (E2 = K2);\n              }\n              break;\n\n            case 58:\n              n2 + b2 + m2 === 0 && (u = l2);\n              break;\n\n            case 44:\n              b2 + v2 + n2 + m2 === 0 && (r2 = 1, y2 += \"\\r\");\n              break;\n\n            case 34:\n            case 39:\n              b2 === 0 && (n2 = n2 === g2 ? 0 : n2 === 0 ? g2 : n2);\n              break;\n\n            case 91:\n              n2 + b2 + v2 === 0 && m2++;\n              break;\n\n            case 93:\n              n2 + b2 + v2 === 0 && m2--;\n              break;\n\n            case 41:\n              n2 + b2 + m2 === 0 && v2--;\n              break;\n\n            case 40:\n              if (n2 + b2 + m2 === 0) {\n                if (q2 === 0) switch (2 * x2 + 3 * K2) {\n                  case 533:\n                    break;\n\n                  default:\n                    q2 = 1;\n                }\n                v2++;\n              }\n\n              break;\n\n            case 64:\n              b2 + v2 + n2 + m2 + u + k2 === 0 && (k2 = 1);\n              break;\n\n            case 42:\n            case 47:\n              if (!(0 < n2 + m2 + v2)) switch (b2) {\n                case 0:\n                  switch (2 * g2 + 3 * e2.charCodeAt(l2 + 1)) {\n                    case 235:\n                      b2 = 47;\n                      break;\n\n                    case 220:\n                      t2 = l2, b2 = 42;\n                  }\n\n                  break;\n\n                case 42:\n                  g2 === 47 && x2 === 42 && t2 + 2 !== l2 && (e2.charCodeAt(t2 + 2) === 33 && (p2 += e2.substring(t2, l2 + 1)), y2 = \"\", b2 = 0);\n              }\n          }\n\n          b2 === 0 && (f2 += y2);\n      }\n\n      K2 = x2;\n      x2 = g2;\n      l2++;\n    }\n\n    t2 = p2.length;\n\n    if (0 < t2) {\n      r2 = c2;\n      if (0 < A2 && (C = H2(2, p2, r2, d2, D, z2, t2, h, a, h), C !== void 0 && (p2 = C).length === 0)) return G3 + p2 + F3;\n      p2 = r2.join(\",\") + \"{\" + p2 + \"}\";\n\n      if (w2 * E2 !== 0) {\n        w2 !== 2 || L2(p2, 2) || (E2 = 0);\n\n        switch (E2) {\n          case 111:\n            p2 = p2.replace(ha, \":-moz-$1\") + p2;\n            break;\n\n          case 112:\n            p2 = p2.replace(Q2, \"::-webkit-input-$1\") + p2.replace(Q2, \"::-moz-$1\") + p2.replace(Q2, \":-ms-input-$1\") + p2;\n        }\n\n        E2 = 0;\n      }\n    }\n\n    return G3 + p2 + F3;\n  }\n\n  function X2(d2, c2, e2) {\n    var h = c2.trim().split(ia);\n    c2 = h;\n    var a = h.length,\n        m2 = d2.length;\n\n    switch (m2) {\n      case 0:\n      case 1:\n        var b2 = 0;\n\n        for (d2 = m2 === 0 ? \"\" : d2[0] + \" \"; b2 < a; ++b2) {\n          c2[b2] = Z2(d2, c2[b2], e2).trim();\n        }\n\n        break;\n\n      default:\n        var v2 = b2 = 0;\n\n        for (c2 = []; b2 < a; ++b2) {\n          for (var n2 = 0; n2 < m2; ++n2) {\n            c2[v2++] = Z2(d2[n2] + \" \", h[b2], e2).trim();\n          }\n        }\n\n    }\n\n    return c2;\n  }\n\n  function Z2(d2, c2, e2) {\n    var h = c2.charCodeAt(0);\n    33 > h && (h = (c2 = c2.trim()).charCodeAt(0));\n\n    switch (h) {\n      case 38:\n        return c2.replace(F2, \"$1\" + d2.trim());\n\n      case 58:\n        return d2.trim() + c2.replace(F2, \"$1\" + d2.trim());\n\n      default:\n        if (0 < 1 * e2 && 0 < c2.indexOf(\"\\f\")) return c2.replace(F2, (d2.charCodeAt(0) === 58 ? \"\" : \"$1\") + d2.trim());\n    }\n\n    return d2 + c2;\n  }\n\n  function P2(d2, c2, e2, h) {\n    var a = d2 + \";\",\n        m2 = 2 * c2 + 3 * e2 + 4 * h;\n\n    if (m2 === 944) {\n      d2 = a.indexOf(\":\", 9) + 1;\n      var b2 = a.substring(d2, a.length - 1).trim();\n      b2 = a.substring(0, d2).trim() + b2 + \";\";\n      return w2 === 1 || w2 === 2 && L2(b2, 1) ? \"-webkit-\" + b2 + b2 : b2;\n    }\n\n    if (w2 === 0 || w2 === 2 && !L2(a, 1)) return a;\n\n    switch (m2) {\n      case 1015:\n        return a.charCodeAt(10) === 97 ? \"-webkit-\" + a + a : a;\n\n      case 951:\n        return a.charCodeAt(3) === 116 ? \"-webkit-\" + a + a : a;\n\n      case 963:\n        return a.charCodeAt(5) === 110 ? \"-webkit-\" + a + a : a;\n\n      case 1009:\n        if (a.charCodeAt(4) !== 100) break;\n\n      case 969:\n      case 942:\n        return \"-webkit-\" + a + a;\n\n      case 978:\n        return \"-webkit-\" + a + \"-moz-\" + a + a;\n\n      case 1019:\n      case 983:\n        return \"-webkit-\" + a + \"-moz-\" + a + \"-ms-\" + a + a;\n\n      case 883:\n        if (a.charCodeAt(8) === 45) return \"-webkit-\" + a + a;\n        if (0 < a.indexOf(\"image-set(\", 11)) return a.replace(ja, \"$1-webkit-$2\") + a;\n        break;\n\n      case 932:\n        if (a.charCodeAt(4) === 45) switch (a.charCodeAt(5)) {\n          case 103:\n            return \"-webkit-box-\" + a.replace(\"-grow\", \"\") + \"-webkit-\" + a + \"-ms-\" + a.replace(\"grow\", \"positive\") + a;\n\n          case 115:\n            return \"-webkit-\" + a + \"-ms-\" + a.replace(\"shrink\", \"negative\") + a;\n\n          case 98:\n            return \"-webkit-\" + a + \"-ms-\" + a.replace(\"basis\", \"preferred-size\") + a;\n        }\n        return \"-webkit-\" + a + \"-ms-\" + a + a;\n\n      case 964:\n        return \"-webkit-\" + a + \"-ms-flex-\" + a + a;\n\n      case 1023:\n        if (a.charCodeAt(8) !== 99) break;\n        b2 = a.substring(a.indexOf(\":\", 15)).replace(\"flex-\", \"\").replace(\"space-between\", \"justify\");\n        return \"-webkit-box-pack\" + b2 + \"-webkit-\" + a + \"-ms-flex-pack\" + b2 + a;\n\n      case 1005:\n        return ka.test(a) ? a.replace(aa, \":-webkit-\") + a.replace(aa, \":-moz-\") + a : a;\n\n      case 1e3:\n        b2 = a.substring(13).trim();\n        c2 = b2.indexOf(\"-\") + 1;\n\n        switch (b2.charCodeAt(0) + b2.charCodeAt(c2)) {\n          case 226:\n            b2 = a.replace(G2, \"tb\");\n            break;\n\n          case 232:\n            b2 = a.replace(G2, \"tb-rl\");\n            break;\n\n          case 220:\n            b2 = a.replace(G2, \"lr\");\n            break;\n\n          default:\n            return a;\n        }\n\n        return \"-webkit-\" + a + \"-ms-\" + b2 + a;\n\n      case 1017:\n        if (a.indexOf(\"sticky\", 9) === -1) break;\n\n      case 975:\n        c2 = (a = d2).length - 10;\n        b2 = (a.charCodeAt(c2) === 33 ? a.substring(0, c2) : a).substring(d2.indexOf(\":\", 7) + 1).trim();\n\n        switch (m2 = b2.charCodeAt(0) + (b2.charCodeAt(7) | 0)) {\n          case 203:\n            if (111 > b2.charCodeAt(8)) break;\n\n          case 115:\n            a = a.replace(b2, \"-webkit-\" + b2) + \";\" + a;\n            break;\n\n          case 207:\n          case 102:\n            a = a.replace(b2, \"-webkit-\" + (102 < m2 ? \"inline-\" : \"\") + \"box\") + \";\" + a.replace(b2, \"-webkit-\" + b2) + \";\" + a.replace(b2, \"-ms-\" + b2 + \"box\") + \";\" + a;\n        }\n\n        return a + \";\";\n\n      case 938:\n        if (a.charCodeAt(5) === 45) switch (a.charCodeAt(6)) {\n          case 105:\n            return b2 = a.replace(\"-items\", \"\"), \"-webkit-\" + a + \"-webkit-box-\" + b2 + \"-ms-flex-\" + b2 + a;\n\n          case 115:\n            return \"-webkit-\" + a + \"-ms-flex-item-\" + a.replace(ba, \"\") + a;\n\n          default:\n            return \"-webkit-\" + a + \"-ms-flex-line-pack\" + a.replace(\"align-content\", \"\").replace(ba, \"\") + a;\n        }\n        break;\n\n      case 973:\n      case 989:\n        if (a.charCodeAt(3) !== 45 || a.charCodeAt(4) === 122) break;\n\n      case 931:\n      case 953:\n        if (la.test(d2) === true) return (b2 = d2.substring(d2.indexOf(\":\") + 1)).charCodeAt(0) === 115 ? P2(d2.replace(\"stretch\", \"fill-available\"), c2, e2, h).replace(\":fill-available\", \":stretch\") : a.replace(b2, \"-webkit-\" + b2) + a.replace(b2, \"-moz-\" + b2.replace(\"fill-\", \"\")) + a;\n        break;\n\n      case 962:\n        if (a = \"-webkit-\" + a + (a.charCodeAt(5) === 102 ? \"-ms-\" + a : \"\") + a, e2 + h === 211 && a.charCodeAt(13) === 105 && 0 < a.indexOf(\"transform\", 10)) return a.substring(0, a.indexOf(\";\", 27) + 1).replace(ma, \"$1-webkit-$2\") + a;\n    }\n\n    return a;\n  }\n\n  function L2(d2, c2) {\n    var e2 = d2.indexOf(c2 === 1 ? \":\" : \"{\"),\n        h = d2.substring(0, c2 !== 3 ? e2 : 10);\n    e2 = d2.substring(e2 + 1, d2.length - 1);\n    return R(c2 !== 2 ? h : h.replace(na, \"$1\"), e2, c2);\n  }\n\n  function ea(d2, c2) {\n    var e2 = P2(c2, c2.charCodeAt(0), c2.charCodeAt(1), c2.charCodeAt(2));\n    return e2 !== c2 + \";\" ? e2.replace(oa, \" or ($1)\").substring(4) : \"(\" + c2 + \")\";\n  }\n\n  function H2(d2, c2, e2, h, a, m2, b2, v2, n2, q2) {\n    for (var g2 = 0, x2 = c2, w3; g2 < A2; ++g2) {\n      switch (w3 = S2[g2].call(B2, d2, x2, e2, h, a, m2, b2, v2, n2, q2)) {\n        case void 0:\n        case false:\n        case true:\n        case null:\n          break;\n\n        default:\n          x2 = w3;\n      }\n    }\n\n    if (x2 !== c2) return x2;\n  }\n\n  function T2(d2) {\n    switch (d2) {\n      case void 0:\n      case null:\n        A2 = S2.length = 0;\n        break;\n\n      default:\n        if (typeof d2 === \"function\") S2[A2++] = d2;else if (typeof d2 === \"object\") for (var c2 = 0, e2 = d2.length; c2 < e2; ++c2) {\n          T2(d2[c2]);\n        } else Y2 = !!d2 | 0;\n    }\n\n    return T2;\n  }\n\n  function U2(d2) {\n    d2 = d2.prefix;\n    d2 !== void 0 && (R = null, d2 ? typeof d2 !== \"function\" ? w2 = 1 : (w2 = 2, R = d2) : w2 = 0);\n    return U2;\n  }\n\n  function B2(d2, c2) {\n    var e2 = d2;\n    33 > e2.charCodeAt(0) && (e2 = e2.trim());\n    V2 = e2;\n    e2 = [V2];\n\n    if (0 < A2) {\n      var h = H2(-1, c2, e2, e2, D, z2, 0, 0, 0, 0);\n      h !== void 0 && typeof h === \"string\" && (c2 = h);\n    }\n\n    var a = M2(O2, e2, c2, 0, 0);\n    0 < A2 && (h = H2(-2, a, e2, e2, D, z2, a.length, 0, 0, 0), h !== void 0 && (a = h));\n    V2 = \"\";\n    E2 = 0;\n    z2 = D = 1;\n    return a;\n  }\n\n  var ca = /^\\0+/g,\n      N2 = /[\\0\\r\\f]/g,\n      aa = /: */g,\n      ka = /zoo|gra/,\n      ma = /([,: ])(transform)/g,\n      ia = /,\\r+?/g,\n      F2 = /([\\t\\r\\n ])*\\f?&/g,\n      fa = /@(k\\w+)\\s*(\\S*)\\s*/,\n      Q2 = /::(place)/g,\n      ha = /:(read-only)/g,\n      G2 = /[svh]\\w+-[tblr]{2}/,\n      da = /\\(\\s*(.*)\\s*\\)/g,\n      oa = /([\\s\\S]*?);/g,\n      ba = /-self|flex-/g,\n      na = /[^]*?(:[rp][el]a[\\w-]+)[^]*/,\n      la = /stretch|:\\s*\\w+\\-(?:conte|avail)/,\n      ja = /([^-])(image-set\\()/,\n      z2 = 1,\n      D = 1,\n      E2 = 0,\n      w2 = 1,\n      O2 = [],\n      S2 = [],\n      A2 = 0,\n      R = null,\n      Y2 = 0,\n      V2 = \"\";\n  B2.use = T2;\n  B2.set = U2;\n  W2 !== void 0 && U2(W2);\n  return B2;\n}\n\nvar unitlessKeys = {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n};\n\nfunction memoize(fn) {\n  var cache = {};\n  return function (arg) {\n    if (cache[arg] === void 0) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\nvar index = memoize(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n});\nvar reactIs = reactIs$1.exports;\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  \"$$typeof\": true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  \"$$typeof\": true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  }\n\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols$1) {\n      keys = keys.concat(getOwnPropertySymbols$1(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e2) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nvar hoistNonReactStatics_cjs = hoistNonReactStatics;\n\nfunction v() {\n  return (v = Object.assign || function (e2) {\n    for (var t2 = 1; t2 < arguments.length; t2++) {\n      var n2 = arguments[t2];\n\n      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);\n    }\n\n    return e2;\n  }).apply(this, arguments);\n}\n\nvar g$1 = function (e2, t2) {\n  for (var n2 = [e2[0]], r2 = 0, o = t2.length; r2 < o; r2 += 1) n2.push(t2[r2], e2[r2 + 1]);\n\n  return n2;\n},\n    S = function (t2) {\n  return t2 !== null && typeof t2 == \"object\" && (t2.toString ? t2.toString() : Object.prototype.toString.call(t2)) === \"[object Object]\" && !reactIs$1.exports.typeOf(t2);\n},\n    w = Object.freeze([]),\n    E = Object.freeze({});\n\nfunction b(e2) {\n  return typeof e2 == \"function\";\n}\n\nfunction _(e2) {\n  return e2.displayName || e2.name || \"Component\";\n}\n\nfunction N(e2) {\n  return e2 && typeof e2.styledComponentId == \"string\";\n}\n\nvar A = typeof process != \"undefined\" && {}.SC_ATTR || \"data-styled\",\n    I = typeof window != \"undefined\" && \"HTMLElement\" in window,\n    P = Boolean(typeof SC_DISABLE_SPEEDY == \"boolean\" ? SC_DISABLE_SPEEDY : typeof process != \"undefined\" && {}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== \"\" ? {}.REACT_APP_SC_DISABLE_SPEEDY : typeof process != \"undefined\" && {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== \"\" ? {}.SC_DISABLE_SPEEDY : false),\n    O = {};\n\nfunction j(e2) {\n  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];\n\n  throw new Error(\"An error occurred. See https://git.io/JUIaE#\" + e2 + \" for more information.\" + (n2.length > 0 ? \" Args: \" + n2.join(\", \") : \"\"));\n}\n\nvar T = function () {\n  function e2(e3) {\n    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;\n  }\n\n  var t2 = e2.prototype;\n  return t2.indexOfGroup = function (e3) {\n    for (var t3 = 0, n2 = 0; n2 < e3; n2++) t3 += this.groupSizes[n2];\n\n    return t3;\n  }, t2.insertRules = function (e3, t3) {\n    if (e3 >= this.groupSizes.length) {\n      for (var n2 = this.groupSizes, r2 = n2.length, o = r2; e3 >= o;) (o <<= 1) < 0 && j(16, \"\" + e3);\n\n      this.groupSizes = new Uint32Array(o), this.groupSizes.set(n2), this.length = o;\n\n      for (var s = r2; s < o; s++) this.groupSizes[s] = 0;\n    }\n\n    for (var i = this.indexOfGroup(e3 + 1), a = 0, c2 = t3.length; a < c2; a++) this.tag.insertRule(i, t3[a]) && (this.groupSizes[e3]++, i++);\n  }, t2.clearGroup = function (e3) {\n    if (e3 < this.length) {\n      var t3 = this.groupSizes[e3],\n          n2 = this.indexOfGroup(e3),\n          r2 = n2 + t3;\n      this.groupSizes[e3] = 0;\n\n      for (var o = n2; o < r2; o++) this.tag.deleteRule(n2);\n    }\n  }, t2.getGroup = function (e3) {\n    var t3 = \"\";\n    if (e3 >= this.length || this.groupSizes[e3] === 0) return t3;\n\n    for (var n2 = this.groupSizes[e3], r2 = this.indexOfGroup(e3), o = r2 + n2, s = r2; s < o; s++) t3 += this.tag.getRule(s) + \"/*!sc*/\\n\";\n\n    return t3;\n  }, e2;\n}(),\n    k = new Map(),\n    x = new Map(),\n    V = 1,\n    B = function (e2) {\n  if (k.has(e2)) return k.get(e2);\n\n  for (; x.has(V);) V++;\n\n  var t2 = V++;\n  return k.set(e2, t2), x.set(t2, e2), t2;\n},\n    M = function (e2) {\n  return x.get(e2);\n},\n    z = function (e2, t2) {\n  t2 >= V && (V = t2 + 1), k.set(e2, t2), x.set(t2, e2);\n},\n    L = \"style[\" + A + '][data-styled-version=\"5.3.1\"]',\n    G = new RegExp(\"^\" + A + '\\\\.g(\\\\d+)\\\\[id=\"([\\\\w\\\\d-]+)\"\\\\].*?\"([^\"]*)'),\n    F = function (e2, t2, n2) {\n  for (var r2, o = n2.split(\",\"), s = 0, i = o.length; s < i; s++) (r2 = o[s]) && e2.registerName(t2, r2);\n},\n    Y = function (e2, t2) {\n  for (var n2 = (t2.innerHTML || \"\").split(\"/*!sc*/\\n\"), r2 = [], o = 0, s = n2.length; o < s; o++) {\n    var i = n2[o].trim();\n\n    if (i) {\n      var a = i.match(G);\n\n      if (a) {\n        var c2 = 0 | parseInt(a[1], 10),\n            u = a[2];\n        c2 !== 0 && (z(u, c2), F(e2, u, a[3]), e2.getTag().insertRules(c2, r2)), r2.length = 0;\n      } else r2.push(i);\n    }\n  }\n},\n    q$1 = function () {\n  return typeof window != \"undefined\" && window.__webpack_nonce__ !== void 0 ? window.__webpack_nonce__ : null;\n},\n    H = function (e2) {\n  var t2 = document.head,\n      n2 = e2 || t2,\n      r2 = document.createElement(\"style\"),\n      o = function (e3) {\n    for (var t3 = e3.childNodes, n3 = t3.length; n3 >= 0; n3--) {\n      var r3 = t3[n3];\n      if (r3 && r3.nodeType === 1 && r3.hasAttribute(A)) return r3;\n    }\n  }(n2),\n      s = o !== void 0 ? o.nextSibling : null;\n\n  r2.setAttribute(A, \"active\"), r2.setAttribute(\"data-styled-version\", \"5.3.1\");\n  var i = q$1();\n  return i && r2.setAttribute(\"nonce\", i), n2.insertBefore(r2, s), r2;\n},\n    $ = function () {\n  function e2(e3) {\n    var t3 = this.element = H(e3);\n    t3.appendChild(document.createTextNode(\"\")), this.sheet = function (e4) {\n      if (e4.sheet) return e4.sheet;\n\n      for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {\n        var o = t4[n2];\n        if (o.ownerNode === e4) return o;\n      }\n\n      j(17);\n    }(t3), this.length = 0;\n  }\n\n  var t2 = e2.prototype;\n  return t2.insertRule = function (e3, t3) {\n    try {\n      return this.sheet.insertRule(t3, e3), this.length++, true;\n    } catch (e4) {\n      return false;\n    }\n  }, t2.deleteRule = function (e3) {\n    this.sheet.deleteRule(e3), this.length--;\n  }, t2.getRule = function (e3) {\n    var t3 = this.sheet.cssRules[e3];\n    return t3 !== void 0 && typeof t3.cssText == \"string\" ? t3.cssText : \"\";\n  }, e2;\n}(),\n    W = function () {\n  function e2(e3) {\n    var t3 = this.element = H(e3);\n    this.nodes = t3.childNodes, this.length = 0;\n  }\n\n  var t2 = e2.prototype;\n  return t2.insertRule = function (e3, t3) {\n    if (e3 <= this.length && e3 >= 0) {\n      var n2 = document.createTextNode(t3),\n          r2 = this.nodes[e3];\n      return this.element.insertBefore(n2, r2 || null), this.length++, true;\n    }\n\n    return false;\n  }, t2.deleteRule = function (e3) {\n    this.element.removeChild(this.nodes[e3]), this.length--;\n  }, t2.getRule = function (e3) {\n    return e3 < this.length ? this.nodes[e3].textContent : \"\";\n  }, e2;\n}(),\n    U = function () {\n  function e2(e3) {\n    this.rules = [], this.length = 0;\n  }\n\n  var t2 = e2.prototype;\n  return t2.insertRule = function (e3, t3) {\n    return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);\n  }, t2.deleteRule = function (e3) {\n    this.rules.splice(e3, 1), this.length--;\n  }, t2.getRule = function (e3) {\n    return e3 < this.length ? this.rules[e3] : \"\";\n  }, e2;\n}(),\n    J = I,\n    X = {\n  isServer: !I,\n  useCSSOMInjection: !P\n},\n    Z = function () {\n  function e2(e3, t3, n2) {\n    e3 === void 0 && (e3 = E), t3 === void 0 && (t3 = {}), this.options = v({}, X, {}, e3), this.gs = t3, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && I && J && (J = false, function (e4) {\n      for (var t4 = document.querySelectorAll(L), n3 = 0, r2 = t4.length; n3 < r2; n3++) {\n        var o = t4[n3];\n        o && o.getAttribute(A) !== \"active\" && (Y(e4, o), o.parentNode && o.parentNode.removeChild(o));\n      }\n    }(this));\n  }\n\n  e2.registerId = function (e3) {\n    return B(e3);\n  };\n\n  var t2 = e2.prototype;\n  return t2.reconstructWithOptions = function (t3, n2) {\n    return n2 === void 0 && (n2 = true), new e2(v({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);\n  }, t2.allocateGSInstance = function (e3) {\n    return this.gs[e3] = (this.gs[e3] || 0) + 1;\n  }, t2.getTag = function () {\n    return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o = t3.target, e3 = n2 ? new U(o) : r2 ? new $(o) : new W(o), new T(e3)));\n    var e3, t3, n2, r2, o;\n  }, t2.hasNameForId = function (e3, t3) {\n    return this.names.has(e3) && this.names.get(e3).has(t3);\n  }, t2.registerName = function (e3, t3) {\n    if (B(e3), this.names.has(e3)) this.names.get(e3).add(t3);else {\n      var n2 = new Set();\n      n2.add(t3), this.names.set(e3, n2);\n    }\n  }, t2.insertRules = function (e3, t3, n2) {\n    this.registerName(e3, t3), this.getTag().insertRules(B(e3), n2);\n  }, t2.clearNames = function (e3) {\n    this.names.has(e3) && this.names.get(e3).clear();\n  }, t2.clearRules = function (e3) {\n    this.getTag().clearGroup(B(e3)), this.clearNames(e3);\n  }, t2.clearTag = function () {\n    this.tag = void 0;\n  }, t2.toString = function () {\n    return function (e3) {\n      for (var t3 = e3.getTag(), n2 = t3.length, r2 = \"\", o = 0; o < n2; o++) {\n        var s = M(o);\n\n        if (s !== void 0) {\n          var i = e3.names.get(s),\n              a = t3.getGroup(o);\n\n          if (i && a && i.size) {\n            var c2 = A + \".g\" + o + '[id=\"' + s + '\"]',\n                u = \"\";\n            i !== void 0 && i.forEach(function (e4) {\n              e4.length > 0 && (u += e4 + \",\");\n            }), r2 += \"\" + a + c2 + '{content:\"' + u + '\"}/*!sc*/\\n';\n          }\n        }\n      }\n\n      return r2;\n    }(this);\n  }, e2;\n}(),\n    K = /(a)(d)/gi,\n    Q = function (e2) {\n  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));\n};\n\nfunction ee(e2) {\n  var t2,\n      n2 = \"\";\n\n  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0) n2 = Q(t2 % 52) + n2;\n\n  return (Q(t2 % 52) + n2).replace(K, \"$1-$2\");\n}\n\nvar te = function (e2, t2) {\n  for (var n2 = t2.length; n2;) e2 = 33 * e2 ^ t2.charCodeAt(--n2);\n\n  return e2;\n},\n    ne = function (e2) {\n  return te(5381, e2);\n};\n\nfunction re(e2) {\n  for (var t2 = 0; t2 < e2.length; t2 += 1) {\n    var n2 = e2[t2];\n    if (b(n2) && !N(n2)) return false;\n  }\n\n  return true;\n}\n\nvar oe = ne(\"5.3.1\"),\n    se = function () {\n  function e2(e3, t2, n2) {\n    this.rules = e3, this.staticRulesId = \"\", this.isStatic = (n2 === void 0 || n2.isStatic) && re(e3), this.componentId = t2, this.baseHash = te(oe, t2), this.baseStyle = n2, Z.registerId(t2);\n  }\n\n  return e2.prototype.generateAndInjectStyles = function (e3, t2, n2) {\n    var r2 = this.componentId,\n        o = [];\n\n    if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e3, t2, n2)), this.isStatic && !n2.hash) {\n      if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId)) o.push(this.staticRulesId);else {\n        var s = Ne(this.rules, e3, t2, n2).join(\"\"),\n            i = ee(te(this.baseHash, s) >>> 0);\n\n        if (!t2.hasNameForId(r2, i)) {\n          var a = n2(s, \".\" + i, void 0, r2);\n          t2.insertRules(r2, i, a);\n        }\n\n        o.push(i), this.staticRulesId = i;\n      }\n    } else {\n      for (var c2 = this.rules.length, u = te(this.baseHash, n2.hash), l2 = \"\", d2 = 0; d2 < c2; d2++) {\n        var h = this.rules[d2];\n        if (typeof h == \"string\") l2 += h;else if (h) {\n          var p2 = Ne(h, e3, t2, n2),\n              f2 = Array.isArray(p2) ? p2.join(\"\") : p2;\n          u = te(u, f2 + d2), l2 += f2;\n        }\n      }\n\n      if (l2) {\n        var m2 = ee(u >>> 0);\n\n        if (!t2.hasNameForId(r2, m2)) {\n          var y2 = n2(l2, \".\" + m2, void 0, r2);\n          t2.insertRules(r2, m2, y2);\n        }\n\n        o.push(m2);\n      }\n    }\n\n    return o.join(\" \");\n  }, e2;\n}(),\n    ie = /^\\s*\\/\\/.*$/gm,\n    ae = [\":\", \"[\", \".\", \"#\"];\n\nfunction ce(e2) {\n  var t2,\n      n2,\n      r2,\n      o,\n      s = e2 === void 0 ? E : e2,\n      i = s.options,\n      a = i === void 0 ? E : i,\n      c2 = s.plugins,\n      u = c2 === void 0 ? w : c2,\n      l2 = new stylis_min(a),\n      d2 = [],\n      h = function (e3) {\n    function t3(t4) {\n      if (t4) try {\n        e3(t4 + \"}\");\n      } catch (e4) {}\n    }\n\n    return function (n3, r3, o2, s2, i2, a2, c3, u2, l3, d3) {\n      switch (n3) {\n        case 1:\n          if (l3 === 0 && r3.charCodeAt(0) === 64) return e3(r3 + \";\"), \"\";\n          break;\n\n        case 2:\n          if (u2 === 0) return r3 + \"/*|*/\";\n          break;\n\n        case 3:\n          switch (u2) {\n            case 102:\n            case 112:\n              return e3(o2[0] + r3), \"\";\n\n            default:\n              return r3 + (d3 === 0 ? \"/*|*/\" : \"\");\n          }\n\n        case -2:\n          r3.split(\"/*|*/}\").forEach(t3);\n      }\n    };\n  }(function (e3) {\n    d2.push(e3);\n  }),\n      f2 = function (e3, r3, s2) {\n    return r3 === 0 && ae.indexOf(s2[n2.length]) !== -1 || s2.match(o) ? e3 : \".\" + t2;\n  };\n\n  function m2(e3, s2, i2, a2) {\n    a2 === void 0 && (a2 = \"&\");\n    var c3 = e3.replace(ie, \"\"),\n        u2 = s2 && i2 ? i2 + \" \" + s2 + \" { \" + c3 + \" }\" : c3;\n    return t2 = a2, n2 = s2, r2 = new RegExp(\"\\\\\" + n2 + \"\\\\b\", \"g\"), o = new RegExp(\"(\\\\\" + n2 + \"\\\\b){2,}\"), l2(i2 || !s2 ? \"\" : s2, u2);\n  }\n\n  return l2.use([].concat(u, [function (e3, t3, o2) {\n    e3 === 2 && o2.length && o2[0].lastIndexOf(n2) > 0 && (o2[0] = o2[0].replace(r2, f2));\n  }, h, function (e3) {\n    if (e3 === -2) {\n      var t3 = d2;\n      return d2 = [], t3;\n    }\n  }])), m2.hash = u.length ? u.reduce(function (e3, t3) {\n    return t3.name || j(15), te(e3, t3.name);\n  }, 5381).toString() : \"\", m2;\n}\n\nvar ue = r$1.createContext();\nue.Consumer;\nvar de = r$1.createContext(),\n    he = (de.Consumer, new Z()),\n    pe = ce();\n\nfunction fe() {\n  return useContext(ue) || he;\n}\n\nfunction me() {\n  return useContext(de) || pe;\n}\n\nvar ve = function () {\n  function e2(e3, t2) {\n    var n2 = this;\n    this.inject = function (e4, t3) {\n      t3 === void 0 && (t3 = pe);\n      var r2 = n2.name + t3.hash;\n      e4.hasNameForId(n2.id, r2) || e4.insertRules(n2.id, r2, t3(n2.rules, r2, \"@keyframes\"));\n    }, this.toString = function () {\n      return j(12, String(n2.name));\n    }, this.name = e3, this.id = \"sc-keyframes-\" + e3, this.rules = t2;\n  }\n\n  return e2.prototype.getName = function (e3) {\n    return e3 === void 0 && (e3 = pe), this.name + e3.hash;\n  }, e2;\n}(),\n    ge = /([A-Z])/,\n    Se = /([A-Z])/g,\n    we = /^ms-/,\n    Ee = function (e2) {\n  return \"-\" + e2.toLowerCase();\n};\n\nfunction be(e2) {\n  return ge.test(e2) ? e2.replace(Se, Ee).replace(we, \"-ms-\") : e2;\n}\n\nvar _e = function (e2) {\n  return e2 == null || e2 === false || e2 === \"\";\n};\n\nfunction Ne(e2, n2, r2, o) {\n  if (Array.isArray(e2)) {\n    for (var s, i = [], a = 0, c2 = e2.length; a < c2; a += 1) (s = Ne(e2[a], n2, r2, o)) !== \"\" && (Array.isArray(s) ? i.push.apply(i, s) : i.push(s));\n\n    return i;\n  }\n\n  if (_e(e2)) return \"\";\n  if (N(e2)) return \".\" + e2.styledComponentId;\n\n  if (b(e2)) {\n    if (typeof (l2 = e2) != \"function\" || l2.prototype && l2.prototype.isReactComponent || !n2) return e2;\n    var u = e2(n2);\n    return Ne(u, n2, r2, o);\n  }\n\n  var l2;\n  return e2 instanceof ve ? r2 ? (e2.inject(r2, o), e2.getName(o)) : e2 : S(e2) ? function e3(t2, n3) {\n    var r3,\n        o2,\n        s2 = [];\n\n    for (var i2 in t2) t2.hasOwnProperty(i2) && !_e(t2[i2]) && (Array.isArray(t2[i2]) && t2[i2].isCss || b(t2[i2]) ? s2.push(be(i2) + \":\", t2[i2], \";\") : S(t2[i2]) ? s2.push.apply(s2, e3(t2[i2], i2)) : s2.push(be(i2) + \": \" + (r3 = i2, (o2 = t2[i2]) == null || typeof o2 == \"boolean\" || o2 === \"\" ? \"\" : typeof o2 != \"number\" || o2 === 0 || r3 in unitlessKeys ? String(o2).trim() : o2 + \"px\") + \";\"));\n\n    return n3 ? [n3 + \" {\"].concat(s2, [\"}\"]) : s2;\n  }(e2) : e2.toString();\n}\n\nvar Ae = function (e2) {\n  return Array.isArray(e2) && (e2.isCss = true), e2;\n};\n\nfunction Ce(e2) {\n  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];\n\n  return b(e2) || S(e2) ? Ae(Ne(g$1(w, [e2].concat(n2)))) : n2.length === 0 && e2.length === 1 && typeof e2[0] == \"string\" ? e2 : Ae(Ne(g$1(e2, n2)));\n}\n\nvar Re = function (e2, t2, n2) {\n  return n2 === void 0 && (n2 = E), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;\n},\n    De = /[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~-]+/g,\n    je = /(^-|-$)/g;\n\nfunction Te(e2) {\n  return e2.replace(De, \"-\").replace(je, \"\");\n}\n\nvar ke = function (e2) {\n  return ee(ne(e2) >>> 0);\n};\n\nfunction xe(e2) {\n  return typeof e2 == \"string\" && true;\n}\n\nvar Ve = function (e2) {\n  return typeof e2 == \"function\" || typeof e2 == \"object\" && e2 !== null && !Array.isArray(e2);\n},\n    Be = function (e2) {\n  return e2 !== \"__proto__\" && e2 !== \"constructor\" && e2 !== \"prototype\";\n};\n\nfunction Me(e2, t2, n2) {\n  var r2 = e2[n2];\n  Ve(t2) && Ve(r2) ? ze(r2, t2) : e2[n2] = t2;\n}\n\nfunction ze(e2) {\n  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];\n\n  for (var o = 0, s = n2; o < s.length; o++) {\n    var i = s[o];\n    if (Ve(i)) for (var a in i) Be(a) && Me(e2, i[a], a);\n  }\n\n  return e2;\n}\n\nvar Le = r$1.createContext();\nLe.Consumer;\nvar Ye = {};\n\nfunction qe(e2, t2, n2) {\n  var o = N(e2),\n      i = !xe(e2),\n      a = t2.attrs,\n      c2 = a === void 0 ? w : a,\n      d2 = t2.componentId,\n      h = d2 === void 0 ? function (e3, t3) {\n    var n3 = typeof e3 != \"string\" ? \"sc\" : Te(e3);\n    Ye[n3] = (Ye[n3] || 0) + 1;\n    var r2 = n3 + \"-\" + ke(\"5.3.1\" + n3 + Ye[n3]);\n    return t3 ? t3 + \"-\" + r2 : r2;\n  }(t2.displayName, t2.parentComponentId) : d2,\n      p2 = t2.displayName,\n      f2 = p2 === void 0 ? function (e3) {\n    return xe(e3) ? \"styled.\" + e3 : \"Styled(\" + _(e3) + \")\";\n  }(e2) : p2,\n      g2 = t2.displayName && t2.componentId ? Te(t2.displayName) + \"-\" + t2.componentId : t2.componentId || h,\n      S2 = o && e2.attrs ? Array.prototype.concat(e2.attrs, c2).filter(Boolean) : c2,\n      A2 = t2.shouldForwardProp;\n  o && e2.shouldForwardProp && (A2 = t2.shouldForwardProp ? function (n3, r2, o2) {\n    return e2.shouldForwardProp(n3, r2, o2) && t2.shouldForwardProp(n3, r2, o2);\n  } : e2.shouldForwardProp);\n\n  var C,\n      I2 = new se(n2, g2, o ? e2.componentStyle : void 0),\n      P2 = I2.isStatic && c2.length === 0,\n      O2 = function (e3, t3) {\n    return function (e4, t4, n3, r2) {\n      var o2 = e4.attrs,\n          i2 = e4.componentStyle,\n          a2 = e4.defaultProps,\n          c3 = e4.foldedComponentIds,\n          d3 = e4.shouldForwardProp,\n          h2 = e4.styledComponentId,\n          p3 = e4.target;\n\n      var f3 = function (e5, t5, n4) {\n        e5 === void 0 && (e5 = E);\n        var r3 = v({}, t5, {\n          theme: e5\n        }),\n            o3 = {};\n        return n4.forEach(function (e6) {\n          var t6,\n              n5,\n              s,\n              i3 = e6;\n\n          for (t6 in b(i3) && (i3 = i3(r3)), i3) r3[t6] = o3[t6] = t6 === \"className\" ? (n5 = o3[t6], s = i3[t6], n5 && s ? n5 + \" \" + s : n5 || s) : i3[t6];\n        }), [r3, o3];\n      }(Re(t4, useContext(Le), a2) || E, t4, o2),\n          y2 = f3[0],\n          g3 = f3[1],\n          S3 = function (e5, t5, n4, r3) {\n        var o3 = fe(),\n            s = me(),\n            i3 = t5 ? e5.generateAndInjectStyles(E, o3, s) : e5.generateAndInjectStyles(n4, o3, s);\n        return i3;\n      }(i2, r2, y2),\n          w2 = n3,\n          _2 = g3.$as || t4.$as || g3.as || t4.as || p3,\n          N2 = xe(_2),\n          A3 = g3 !== t4 ? v({}, t4, {}, g3) : t4,\n          C2 = {};\n\n      for (var I3 in A3) I3[0] !== \"$\" && I3 !== \"as\" && (I3 === \"forwardedAs\" ? C2.as = A3[I3] : (d3 ? d3(I3, index, _2) : !N2 || index(I3)) && (C2[I3] = A3[I3]));\n\n      return t4.style && g3.style !== t4.style && (C2.style = v({}, t4.style, {}, g3.style)), C2.className = Array.prototype.concat(c3, h2, S3 !== h2 ? S3 : null, t4.className, g3.className).filter(Boolean).join(\" \"), C2.ref = w2, createElement(_2, C2);\n    }(C, e3, t3, P2);\n  };\n\n  return O2.displayName = f2, (C = r$1.forwardRef(O2)).attrs = S2, C.componentStyle = I2, C.displayName = f2, C.shouldForwardProp = A2, C.foldedComponentIds = o ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : w, C.styledComponentId = g2, C.target = o ? e2.target : e2, C.withComponent = function (e3) {\n    var r2 = t2.componentId,\n        o2 = function (e4, t3) {\n      if (e4 == null) return {};\n      var n3,\n          r3,\n          o3 = {},\n          s2 = Object.keys(e4);\n\n      for (r3 = 0; r3 < s2.length; r3++) n3 = s2[r3], t3.indexOf(n3) >= 0 || (o3[n3] = e4[n3]);\n\n      return o3;\n    }(t2, [\"componentId\"]),\n        s = r2 && r2 + \"-\" + (xe(e3) ? e3 : Te(_(e3)));\n\n    return qe(e3, v({}, o2, {\n      attrs: S2,\n      componentId: s\n    }), n2);\n  }, Object.defineProperty(C, \"defaultProps\", {\n    get: function () {\n      return this._foldedDefaultProps;\n    },\n    set: function (t3) {\n      this._foldedDefaultProps = o ? ze({}, e2.defaultProps, t3) : t3;\n    }\n  }), C.toString = function () {\n    return \".\" + C.styledComponentId;\n  }, i && hoistNonReactStatics_cjs(C, e2, {\n    attrs: true,\n    componentStyle: true,\n    displayName: true,\n    foldedComponentIds: true,\n    shouldForwardProp: true,\n    styledComponentId: true,\n    target: true,\n    withComponent: true\n  }), C;\n}\n\nvar He = function (e2) {\n  return function e3(t2, r2, o) {\n    if (o === void 0 && (o = E), !reactIs$1.exports.isValidElementType(r2)) return j(1, String(r2));\n\n    var s = function () {\n      return t2(r2, o, Ce.apply(void 0, arguments));\n    };\n\n    return s.withConfig = function (n2) {\n      return e3(t2, r2, v({}, o, {}, n2));\n    }, s.attrs = function (n2) {\n      return e3(t2, r2, v({}, o, {\n        attrs: Array.prototype.concat(o.attrs, n2).filter(Boolean)\n      }));\n    }, s;\n  }(qe, e2);\n};\n\n[\"a\", \"abbr\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"bdi\", \"bdo\", \"big\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"small\", \"source\", \"span\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"circle\", \"clipPath\", \"defs\", \"ellipse\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"text\", \"textPath\", \"tspan\"].forEach(function (e2) {\n  He[e2] = He(e2);\n});\n\nvar $e = function () {\n  function e2(e3, t3) {\n    this.rules = e3, this.componentId = t3, this.isStatic = re(e3), Z.registerId(this.componentId + 1);\n  }\n\n  var t2 = e2.prototype;\n  return t2.createStyles = function (e3, t3, n2, r2) {\n    var o = r2(Ne(this.rules, t3, n2, r2).join(\"\"), \"\"),\n        s = this.componentId + e3;\n    n2.insertRules(s, s, o);\n  }, t2.removeStyles = function (e3, t3) {\n    t3.clearRules(this.componentId + e3);\n  }, t2.renderStyles = function (e3, t3, n2, r2) {\n    e3 > 2 && Z.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t3, n2, r2);\n  }, e2;\n}();\n\nfunction We(e2) {\n  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), o = 1; o < t2; o++) n2[o - 1] = arguments[o];\n\n  var i = Ce.apply(void 0, [e2].concat(n2)),\n      a = \"sc-global-\" + ke(JSON.stringify(i)),\n      u = new $e(i, a);\n\n  function l2(e3) {\n    var t3 = fe(),\n        n3 = me(),\n        o2 = useContext(Le),\n        l3 = useRef(t3.allocateGSInstance(a)).current;\n    return t3.server && h(l3, e3, t3, o2, n3), useLayoutEffect(function () {\n      if (!t3.server) return h(l3, e3, t3, o2, n3), function () {\n        return u.removeStyles(l3, t3);\n      };\n    }, [l3, e3, t3, o2, n3]), null;\n  }\n\n  function h(e3, t3, n3, r2, o2) {\n    if (u.isStatic) u.renderStyles(e3, O, n3, o2);else {\n      var s = v({}, t3, {\n        theme: Re(t3, r2, l2.defaultProps)\n      });\n      u.renderStyles(e3, s, n3, o2);\n    }\n  }\n\n  return r$1.memo(l2);\n}\n\nvar styled = He;\nconst StyledDropdown = styled.div(_templateObject(), ({\n  dropdownBorderColor\n}) => dropdownBorderColor, ({\n  dropdownHoverColor\n}) => dropdownHoverColor);\nvar jsxRuntime = {\n  exports: {}\n};\nvar reactJsxRuntime_production_min = {};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n  if (val === null || val === void 0) {\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  }\n\n  return Object(val);\n}\n\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    }\n\n    var test1 = new String(\"abc\");\n    test1[5] = \"de\";\n\n    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n      return false;\n    }\n\n    var test2 = {};\n\n    for (var i = 0; i < 10; i++) {\n      test2[\"_\" + String.fromCharCode(i)] = i;\n    }\n\n    var order2 = Object.getOwnPropertyNames(test2).map(function (n2) {\n      return test2[n2];\n    });\n\n    if (order2.join(\"\") !== \"0123456789\") {\n      return false;\n    }\n\n    var test3 = {};\n    \"abcdefghijklmnopqrst\".split(\"\").forEach(function (letter) {\n      test3[letter] = letter;\n    });\n\n    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nshouldUseNative() ? Object.assign : function (target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n\n  return to;\n};\n/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar f = r$1,\n    g = 60103;\nreactJsxRuntime_production_min.Fragment = 60107;\n\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var h = Symbol.for;\n  g = h(\"react.element\");\n  reactJsxRuntime_production_min.Fragment = h(\"react.fragment\");\n}\n\nvar m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,\n    n = Object.prototype.hasOwnProperty,\n    p = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nfunction q(c2, a, k2) {\n  var b2,\n      d2 = {},\n      e2 = null,\n      l2 = null;\n  k2 !== void 0 && (e2 = \"\" + k2);\n  a.key !== void 0 && (e2 = \"\" + a.key);\n  a.ref !== void 0 && (l2 = a.ref);\n\n  for (b2 in a) n.call(a, b2) && !p.hasOwnProperty(b2) && (d2[b2] = a[b2]);\n\n  if (c2 && c2.defaultProps) for (b2 in a = c2.defaultProps, a) d2[b2] === void 0 && (d2[b2] = a[b2]);\n  return {\n    $$typeof: g,\n    type: c2,\n    key: e2,\n    ref: l2,\n    props: d2,\n    _owner: m.current\n  };\n}\n\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\n\nconst Dropdown = ({\n  onClick,\n  matchedRecords = [],\n  dropdownBorderColor,\n  dropdownHoverColor\n}) => {\n  return (\n    /* @__PURE__ */\n    jsx(StyledDropdown, {\n      className: \"react-search-box-dropdown\",\n      dropdownHoverColor,\n      dropdownBorderColor,\n      children:\n      /* @__PURE__ */\n      jsx(\"ul\", {\n        children: matchedRecords.map(record => {\n          return (\n            /* @__PURE__ */\n            jsx(\"li\", {\n              className: \"react-search-box-dropdown-list-item\",\n              onClick: () => onClick(record),\n              children: record.item.value\n            }, record.item.key)\n          );\n        })\n      })\n    })\n  );\n};\n\nconst useOutsideClick = (ref, setDropdownVisibility, setValue) => {\n  useEffect(() => {\n    const handleClickOutside = event => {\n      if (ref.current && !ref.current.contains(event.target)) {\n        setDropdownVisibility(false);\n        setValue(\"\");\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [ref]);\n};\n\nconst StyledInput = styled.input(_templateObject2(), ({\n  inputFontSize\n}) => inputFontSize, ({\n  leftIcon,\n  iconBoxSize\n}) => leftIcon ? \"10px \".concat(iconBoxSize) : \"10px 20px\", ({\n  inputHeight\n}) => inputHeight, ({\n  inputBorderColor\n}) => inputBorderColor, ({\n  inputFontColor\n}) => inputFontColor, ({\n  inputBackgroundColor\n}) => inputBackgroundColor);\nconst StyledIconContainer = styled.span(_templateObject3(), ({\n  inputHeight\n}) => inputHeight, ({\n  iconBoxSize\n}) => iconBoxSize);\nconst StyledInputContainer = styled.span(_templateObject4());\n\nconst Input = ({\n  placeholder,\n  value,\n  onChange,\n  onFocus,\n  inputFontColor,\n  inputBorderColor,\n  inputFontSize,\n  inputHeight,\n  inputBackgroundColor,\n  autoFocus,\n  leftIcon,\n  iconBoxSize,\n  type\n}) => {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    var _a;\n\n    !!autoFocus && ((_a = inputRef.current) == null ? void 0 : _a.focus());\n  }, []);\n\n  const leftIconNode = () => {\n    if (!leftIcon) {\n      return null;\n    }\n\n    return (\n      /* @__PURE__ */\n      jsx(StyledIconContainer, {\n        iconBoxSize,\n        inputHeight,\n        children: leftIcon\n      })\n    );\n  };\n\n  return (\n    /* @__PURE__ */\n    jsxs(StyledInputContainer, {\n      children: [\n      /* @__PURE__ */\n      jsx(StyledInput, {\n        type,\n        placeholder,\n        value,\n        onChange,\n        onFocus,\n        ref: inputRef,\n        inputFontColor,\n        inputBorderColor,\n        inputFontSize,\n        inputHeight,\n        inputBackgroundColor,\n        leftIcon,\n        iconBoxSize\n      }), leftIconNode()]\n    })\n  );\n};\n\nconst GlobalStyle = We(_templateObject5());\nconst StyledContainer = styled.div(_templateObject6());\n\nconst ReactSearchBox = ({\n  placeholder = \"\",\n  data = [],\n  fuseConfigs,\n  autoFocus = false,\n  onSelect,\n  onFocus,\n  onChange,\n  inputBackgroundColor = \"#fff\",\n  inputFontColor = \"#000\",\n  inputBorderColor = \"#cacaca96\",\n  inputFontSize = \"14px\",\n  inputHeight = \"40px\",\n  dropdownHoverColor = \"#ccc\",\n  dropdownBorderColor = \"#cacaca96\",\n  clearOnSelect = false,\n  leftIcon,\n  iconBoxSize = \"24px\",\n  type = \"text\"\n}) => {\n  const _useState = useState([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        matchedRecords = _useState2[0],\n        setMatchedRecords = _useState2[1];\n\n  const _useState3 = useState(\"\"),\n        _useState4 = _slicedToArray(_useState3, 2),\n        value = _useState4[0],\n        setValue = _useState4[1];\n\n  const _useState5 = useState(false),\n        _useState6 = _slicedToArray(_useState5, 2),\n        showDropdown = _useState6[0],\n        setDropdownVisibility = _useState6[1];\n\n  const wrapperRef = useRef(null);\n  useOutsideClick(wrapperRef, setDropdownVisibility, setValue);\n  const defaultFuseConfigs = {\n    threshold: 0.05,\n    location: 0,\n    distance: 100,\n    minMatchCharLength: 1,\n    keys: [\"value\"]\n  };\n  const configs = Object.assign({}, defaultFuseConfigs, fuseConfigs);\n  const fuse = new Fuse(data, configs);\n\n  const handleInputChange = e2 => {\n    const value2 = e2.target.value;\n    const matchedRecords2 = fuse.search(value2);\n    setValue(value2);\n    setMatchedRecords(matchedRecords2);\n    setDropdownVisibility(true);\n    !!onChange && onChange(value2);\n  };\n\n  const inputNode = () => {\n    return (\n      /* @__PURE__ */\n      jsx(Input, {\n        placeholder,\n        value,\n        onChange: handleInputChange,\n        autoFocus: autoFocus ? autoFocus : false,\n        onFocus: onFocus ? onFocus : void 0,\n        inputFontColor,\n        inputBorderColor,\n        inputFontSize,\n        inputHeight,\n        inputBackgroundColor,\n        leftIcon,\n        iconBoxSize,\n        type\n      })\n    );\n  };\n\n  const handleDropdownItemClick = record => {\n    if (clearOnSelect) {\n      setValue(\"\");\n    } else {\n      setValue(record.item.value);\n    }\n\n    setDropdownVisibility(false);\n    !!onSelect && onSelect(record);\n    !!onChange && onChange(record.item.value);\n  };\n\n  const dropdownNode = () => {\n    if (!showDropdown) return false;\n    return (\n      /* @__PURE__ */\n      jsx(Dropdown, {\n        matchedRecords,\n        onClick: handleDropdownItemClick,\n        dropdownHoverColor,\n        dropdownBorderColor\n      })\n    );\n  };\n\n  return (\n    /* @__PURE__ */\n    jsx(\"div\", {\n      ref: wrapperRef,\n      children:\n      /* @__PURE__ */\n      jsxs(StyledContainer, {\n        children: [\n        /* @__PURE__ */\n        jsx(GlobalStyle, {}), inputNode(), dropdownNode()]\n      })\n    })\n  );\n};\n\nexport { ReactSearchBox as default };","map":null,"metadata":{},"sourceType":"module"}